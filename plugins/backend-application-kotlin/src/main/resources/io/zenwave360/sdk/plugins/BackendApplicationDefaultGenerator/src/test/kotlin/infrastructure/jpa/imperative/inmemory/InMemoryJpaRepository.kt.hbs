package {{layout.infrastructureRepositoryPackage}}.inmemory

import org.springframework.dao.EmptyResultDataAccessException
import org.springframework.data.domain.Example
import org.springframework.data.domain.Page
import org.springframework.data.domain.PageImpl
import org.springframework.data.domain.Pageable
import org.springframework.data.domain.Sort
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.repository.query.FluentQuery
import org.apache.commons.lang3.reflect.FieldUtils

import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Map
import java.util.Optional
import java.util.UUID
import java.util.function.Function
import java.util.stream.Collectors
import java.util.stream.StreamSupport

import org.apache.commons.lang3.ObjectUtils.firstNonNull

class InMemoryJpaRepository<T> : JpaRepository<T, {{idJavaType}}> {

    interface PrimaryKeyGenerator<{{idJavaType}}> {
        fun next(): {{idJavaType}}
    }

    private val entities: MutableMap<{{idJavaType}}, T> = HashMap()

    // private val primaryKeyGenerator: PrimaryKeyGenerator<{{idJavaType}}> = PrimaryKeyGenerator { UUID.randomUUID().toString() }
    private var nextId: Long = 0
    private val primaryKeyGenerator: PrimaryKeyGenerator<Long> = object : PrimaryKeyGenerator<Long> {
        override fun next(): Long = nextId++
    }

    fun clear() {
        nextId = 0
        entities.clear()
    }

    fun getEntities(): Map<{{idJavaType}}, T> {
        return entities
    }

    fun containsKey(key: {{idJavaType}}): Boolean {
        return entities.containsKey(key)
    }

    fun containsEntity(entity: T): Boolean {
        return entities.containsValue(entity)
    }

    protected fun <F> readField(target: Any, fieldName: String): F {
        try {
            @Suppress("UNCHECKED_CAST")
            return FieldUtils.readField(target, fieldName, true) as F
        } catch (e: IllegalAccessException) {
            throw IllegalArgumentException("Field not found or not accessible: $fieldName")
        }
    }

    protected fun writeField(target: Any, fieldName: String, value: Any?) {
        try {
            FieldUtils.writeField(target, fieldName, value, true)
        } catch (e: IllegalAccessException) {
            throw IllegalArgumentException("Field not found or not accessible: $fieldName")
        }
    }

    protected fun <F> findByField(fieldName: String, value: F): List<T> {
        return entities.values.stream().filter { entity -> isSameValue(value, readField(entity, fieldName)) }.collect(Collectors.toList())
    }

    protected fun <F> findByUniqueField(fieldName: String, value: F): T? {
        val foundEntities = findByField(fieldName, value)
        return when {
            foundEntities.isEmpty() -> null
            foundEntities.size == 1 -> foundEntities[0]
            else -> throw IllegalArgumentException("Field $fieldName is not unique, found ${foundEntities.size} entities: $foundEntities")
        }
    }

    protected fun contains(values: Iterable<*>, value: Any?): Boolean {
        return StreamSupport.stream(values.spliterator(), false).anyMatch { e -> isSameValue(e, value) }
    }

    protected fun isSameValue(o1: Any?, o2: Any?): Boolean {
        return if (o1 == null) {
            o2 == null
        } else {
            o1 == o2
        }
    }

    override fun getReferenceById(id: {{idJavaType}}): T {
        return findByUniqueField("id", id) ?: throw EmptyResultDataAccessException("Entity with id $id not found", 1)
    }

    override fun getOne(id: {{idJavaType}}): T {
        return getReferenceById(id)
    }

    override fun getById(id: {{idJavaType}}): T {
        return getReferenceById(id)
    }

    override fun <S : T> save(entity: S): S {
        if (entity == null) {
            throw IllegalArgumentException("entity must not be null")
        }
        val id = firstNonNull(readField<{{idJavaType}}>(entity, "id"), primaryKeyGenerator.next())
        writeField(entity, "id", id)
        entities[id] = entity
        return entity
    }

    override fun <S : T> saveAll(entitiesToSave: Iterable<S>): List<S> {
        if (entitiesToSave == null) {
            throw IllegalArgumentException("entitiesToSave must not be null")
        }
        return StreamSupport.stream(entitiesToSave.spliterator(), false).map { e -> save(e) }.collect(Collectors.toList())
    }

    override fun flush() {
        // No-op
    }

    override fun <S : T> saveAndFlush(entity: S): S {
        return save(entity)
    }

    override fun <S : T> saveAllAndFlush(entities: Iterable<S>): List<S> {
        return saveAll(entities)
    }

    override fun findById(id: {{idJavaType}}): Optional<T> {
        return Optional.ofNullable(findByUniqueField("id", id))
    }

    override fun existsById(id: {{idJavaType}}): Boolean {
        return findById(id).isPresent
    }

    override fun findAll(): List<T> {
        return ArrayList(entities.values)
    }

    override fun findAllById(ids: Iterable<{{idJavaType}}>): List<T> {
        return entities.values.stream().filter { e -> contains(ids, readField(e, "id")) }.collect(Collectors.toList())
    }

    override fun count(): Long {
        return entities.size.toLong()
    }

    override fun deleteById(id: {{idJavaType}}) {
        if (id == null) {
            throw IllegalArgumentException("id must not be null")
        }
        val removedEntity = entities.remove(id)
        if (removedEntity == null) {
            throw EmptyResultDataAccessException("Entity with id $id not found", 1)
        }
    }

    override fun delete(entity: T) {
        if (entity == null) {
            throw IllegalArgumentException("entity must not be null")
        }
        entities.remove(readField(entity, "id"))
    }

    override fun deleteAllById(ids: Iterable<{{idJavaType}}>) {
        if (ids == null) {
            throw IllegalArgumentException("ids must not be null")
        }
        ids.forEach { id -> entities.remove(id) }
    }

    override fun deleteAll(entitiesToDelete: Iterable<T>) {
        if (entitiesToDelete == null) {
            throw IllegalArgumentException("entitiesToDelete must not be null")
        }
        for (entity in entitiesToDelete) {
            delete(entity)
        }
    }

    override fun deleteAll() {
        entities.clear()
    }

    override fun deleteAllInBatch(entities: Iterable<T>) {
        deleteAll(entities)
    }

    override fun deleteAllByIdInBatch(ids: Iterable<{{idJavaType}}>) {
        deleteAllById(ids)
    }

    override fun deleteAllInBatch() {
        deleteAll()
    }

    override fun findAll(sort: Sort): List<T> {
        // Sorting not implemented
        return findAll()
    }

    override fun findAll(pageable: Pageable): Page<T> {
        val total = count().toInt()
        val offset = pageable.offset.toInt()
        val limit = pageable.pageSize
        return PageImpl(findAll().subList(offset, Math.min(offset + limit, total)), pageable, total.toLong())
    }

    override fun <S : T> findOne(example: Example<S>): Optional<S> {
        throw UnsupportedOperationException("Not yet implemented")
    }

    override fun <S : T> findAll(example: Example<S>): List<S> {
        throw UnsupportedOperationException("Not yet implemented")
    }

    override fun <S : T> findAll(example: Example<S>, sort: Sort): List<S> {
        throw UnsupportedOperationException("Not yet implemented")
    }

    override fun <S : T> findAll(example: Example<S>, pageable: Pageable): Page<S> {
        throw UnsupportedOperationException("Not yet implemented")
    }

    override fun <S : T> count(example: Example<S>): Long {
        throw UnsupportedOperationException("Not yet implemented")
    }

    override fun <S : T> exists(example: Example<S>): Boolean {
        throw UnsupportedOperationException("Not yet implemented")
    }

    override fun <S : T, R> findBy(example: Example<S>, queryFunction: Function<FluentQuery.FetchableFluentQuery<S>, R>): R {
        throw UnsupportedOperationException("Not yet implemented")
    }
}