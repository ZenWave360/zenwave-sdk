package {{basePackage}}.core.implementation.mappers;

import {{basePackage}}.core.domain.*;
import {{basePackage}}.core.inbound.dtos.*;

import org.mapstruct.AfterMapping;
import java.util.List;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;
import org.springframework.data.domain.Page;

@Mapper
public interface {{entity.className}}Mapper {

    {{entity.className}}Mapper INSTANCE = Mappers.getMapper({{entity.className}}Mapper.class);

  {{~#each (findAggregateInputs entity) as |input|}}
    {{~#if (not (eq entity.className input))}}
    {{entity.className}} asEntity({{input}} input);
    {{~/if}}

    {{#unless (skipEntityId entity)~}}@Mapping(target = "id", ignore = true){{/unless~}}
    {{entity.className}} update(@MappingTarget {{entity.className}} entity, {{input}} input);
  {{~/each}}

  {{~#each (findAggregateOutputs entity) as |output|}}
    {{output}} as{{output}}({{entity.className}} entity);
    List<{{output}}> as{{output}}List(List<{{entity.className}}> entity);
    default Page<{{output}}> as{{output}}Page(Page<{{entity.className}}> page) {
      return page.map(this::as{{output}});
    }
  {{~/each}}

    {{~assign 'relationships' (findOwnedOneToManyRelationships entity)}}
    {{~#if relationships}}
    @AfterMapping
    default void manageRelationships(@MappingTarget {{entity.className}} entity) {
        {{~#each relationships as |relationship|}}
        if(entity.get{{capitalize relationship.fieldName}}() != null) {
          entity.get{{capitalize relationship.fieldName}}().forEach({{relationship.fieldName}} -> {{relationship.fieldName}}.set{{capitalize relationship.otherEntityFieldName}}(entity));
        }
        {{~/each}}
    }
    {{~/if}}
}
